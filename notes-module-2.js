/*Оператор switch
Оператор switch дозволяє виконувати різні дії залежно від значення виразу. Використання switch є більш компактним і зручним способом для 
порівняння виразів з кількома варіантами, ніж інструкції if...else та else...if.
Як це працює:
1.Вираз (expression) в операторі switch обчислюється.
2.Значення виразу порівнюється з кожним блоком case зверху вниз.
3.Якщо значення виразу відповідає значенню в блоці case, виконується код цього блоку.
4.Коли виконання коду блоку case завершено, необхідно використовувати оператор break, щоб вийти зі switch. 
Це запобігає виконанню коду в наступних блоках case. Якщо break не поставити буде такий собі "дріл" вниз. 
5.Якщо жодне значення не відповідає виразу, виконається код у блоці default (якщо він є).
 */

function chooseYourFruit(value) {
  switch (value) {
    case 'orange':
      return 'You chose orange';
      break;
    case 'apple':
      return 'You chose apple';
      break;
    case 'banana':
      return 'You chose banana';
      break;
    default:
      return 'there aren`t this kind of fruit';
  }
}

console.log(chooseYourFruit('banana'));

function chooseDay(day) {
  switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return 'this is a working day';
      break;
    case 6:
    case 7:
      return 'this is a day off';
      break;
    default:
      return 'invalid';
  }
}

console.log(chooseDay(4)); // 'this is a working day'

/**Наразі тобі знайомі кілька способів, як зробити розгалуження. Під час вибору слід пам’ятати:

Інструкція if є універсальною. Інструкції if…else і else…if використовуються, коли потрібно прописати декілька умов. 
Отже, ці інструкції зазвичай довші, ніж інші способи розгалужень.
Тернарний оператор краще використовувати для присвоєння або повернення значення з тіла функції. 
В умові тернарного оператора може бути все що завгодно: перевірка рівності / нерівності, на більше / менше, просто перевірка на будь чого.

Пам’ятай про обмеження: у нього має бути рівно 2 сценарії, не більше.


Оператор switch перевіряє тільки на сувору рівність.

Використовуючи оператор switch, завжди: 
— пам’ятай про оператор break;
— використовуй тільки 1 default, він завжди має бути останнім. */

// Будь-яка конструкція, що використовує фігурні дужки {} (умови, функції, цикли тощо) створює нову локальну блочну область видимості.

/**Логічні оператори &&(і) та ||(або)
 * 
 Оператор && використовують для того щоб перевірити чи відповідає задане значення двом умовам (обидвом умовам). Н-д, тобі треба щоб число
 було і менше 10 і більше 3. Нижче код. Оператор && шукає перше фолс і якщо його не знайдено, то просто повертає значення правого операнда.
 */
function checkNumber(number) {
  if (number < 10 && number > 3) {
    return 'Access granted';
  } else {
    return 'Access is denied';
  }
}
console.log(checkNumber(12)); // Access is denied
console.log(checkNumber(5)); // Access granted

/**Оператор ||(або) перевіряє чи задовільняє задане значення хоча б одній умові. Оператор || шукає перше тру, і якщо його не знайдено, то повертає значення правого операнда.
* Наприклад, для того щоб надати користувачу доступ до всіх функцій додатку, треба щоб в нього була підписка або "pro", або "vip", в іншому
 випадку доступу не буде, до оплати відповідного тарифу. Код нижче.
 */

function featuresAccess(subscriptionType) {
  if (subscriptionType === 'pro' || subscriptionType === 'vip') {
    return 'You are able to use all features without any limits';
  } else {
    return 'You need to get vip or pro subscription to use all features!';
  }
}

console.log(featuresAccess('vip')); // You are able to use all features without any limits
/* Логічне "НІ". Логічне «НІ» приводить операнд до логічного 
значення (true або false) і потім заперечує (інвертує) його, тобто заміняє на протилежне: true —> false, а false —> true.
На практиці логічне заперечення використовується для перевірки від зворотного. Наприклад, можна дозволити написати повідомлення в чаті, 
лише якщо користувач не заблокований. 
*/

function canText(isBlocked) {
  if (!isBlocked) {
    return 'You can write down your message';
  } else {
    return 'You are blocked';
  }
}

console.log(canText(false)); // You can write down your message

// Властивості та методи рядків
/**Властивість - це опис сутності. Н-д, у рядків є властивість length - це кількість символів в рядку (пробіл це теж символ).
 Для доступу до властивості використовуємо крапку. Н-д, message.length.
 const message = "JavaScript is awesome";
 console.log(message.length); // 21

 Методи - це дії, які можна виконати з сутністю, тобто якимось чином її змінити, повпливати на неї.
 Н-д у рядків є метод message.toUpperCase().
 Виклик методу дуже схожий на доступ до властивості, але наприкінці додаються круглі дужки, як при виклику функції.
 const message = "JavaScript is awesome";
 console.log(message.toUpperCase()); // "JAVASCRIPT IS AWESOME"

/*Методи рядків:
1. Метод trim(): використується для видалення пробілів на початку та в кінці рядка. Типу як "зістригає лишнє по боках":)
Це дозволяє "очистити" рядок від зайвих пробілів, наприклад під час обробки введення тексту користувачем в елементи форми, 
видаливши зайві пробіли, які могли бути додані випадково. Не змінює вихідний рядок.
  message.trim()
const input = " JavaScript is awesome!    ";
const trimmedInput = input.trim();
console.log(trimmedInput); // "JavaScript is awesome!"
console.log(input); // " JavaScript is awesome!    "
2. Метод slice(): копіює підрядок із вихідного рядка, починаючи з індексу startIndex і до (не включаючи) індексу endIndex, 
  і повертає цю копію як новий рядок. Параметр endIndex є необов'язковим. Якщо endIndex не вказаний, витягуються всі елементи до кінця рядка.
  Якщо викликати метод slice() без аргументів, він створює точну копію рядка і повертає її. Не змінює вихідний рядок.
  message.slice(startIndex, endIndex);
3. Методи toLowerCase(), toUpperCase().
Не змінюють вихідний рядок.
4. Метод includes(): використовується для перевірки наявності підрядка у рядку. Регістр символів у рядку й підрядку має значення. 
  Літера a, наприклад, не дорівнює літері A.
   str.includes(substring)
5. Методи startsWith() та endsWith() - призначені для перевірки початку й закінчення рядка відповідно. Вони повертають булеве значення true 
або false, залежно від того, чи відповідає початок або кінець рядка заданому значенню. Чутливі до регістру.
str.startsWith(substr)
const str = "Hello, world!";
console.log(str.startsWith("Hello")); // true
6. Метод indexOf() - використовується для пошуку першого входження підрядка в рядок. Він повертає:
- індекс першого входження (індекс першого символу) підрядка, якщо він знайдений або
- -1, якщо підрядок не виявлено
str.indexOf(substr)
const message = "Welcome to Bahamas!";
const index = message.indexOf("to");
console.log(index); // 8
const message = "Welcome to Bahamas!";
const index = message.indexOf("hello");
console.log(index); // -1
7. Методи padStart(target length, 'symbol') і padEnd(target length, "symbol") - це методи рядків. Вони додають спереді або ззаді до рядка символи,
 які ти задає як другий параметр. Перший параметр це фінальна довжина твого рядка - на ньому буде базуватись те, ск символів додасться до рядка.
*/
/*-------------------------------------------------------------------------------------------------------------------------------------------------*/
/* Цикли

Саме для багаторазового повторення однієї частини коду використовуються цикли.

Цикл while - Конструкція while створює цикл, який виконує блок коду в тілі циклу, поки умова для виходу оцінюється як true.
while (condition) {
  statement // код, тіло циклу
}
Цикл while — це цикл з передумовою, тобто він виконується доки істинна певна умова, зазначена перед його початком. 
Цю умову перевіряють до виконання тіла циклу, тому тіло може бути не виконано жодного разу, якщо умова від самого початку хибна.

let count = 0;

while (count < 10) {
  console.log(`Count: ${count}`);
  count += 1;
}
Всередині циклу ти маєш вказувати як змінюється змінна вказана в умові, н-д змінна count збільшується на одиницю або 
змінна отримується з prompt: number = prompt('Enter your number');
І тоді після оновлення значення змінної, умова циклу while буде знову перевірятись, і так далі, доки умова не стане false.


Задачка на цикл з якою я просиділа 25хв.
Функція calculateTotal(number) приймає ціле число (параметр number). Доповни код функції так, щоб вона повертала суму всіх цілих чисел 
від одиниці до цього числа включно. Наприклад, якщо number дорівнює 3, то сума - це 1 + 2 + 3, тобто 6.

function calculateTotal(number) {
  let total = 0;
  while(number >= 1){
    total = total + number 
    number -= 1
  }
  return total;
}
Логіка: 
Йдемо з кінця. Рядок додавання завжди закінчується числом number. Попереднє число менше на одиницю. 
Виходить зправа наліво йде зменшення number на 1. Тому так і рахуємо, спочатку до тотал додаємо number. 
Тоді number зменшуємо на 1 і додаємо до тотал і так допоки number не буде менше 1. 

Інший варіант.
function calculateTotal(number) {
  let total = 0;
  let index = 0;
  while(number > index) {
    index += 1;
    total += index;
  }
  return total;
}
Логіка: 
Виходить яке у нас number стільки і разів index буде збільшуватись на одиницю. Н-д number 4, чотири рази пройде операція збільшення 
індексу на одиницю. 4: 1 + 2 + 3 + 4 . 


 Цикл do…while
Цикли while і do...while працюють схожим чином, але мають одну ключову відмінність. 
Під час використання циклу do...while код у тілі циклу виконується принаймні один раз, навіть якщо умова не виконується з самого початку.
do {
   statement // код, який буде виконуватися
} while (condition);

 Блок коду всередині do виконується в перший раз незалежно від виконання умови.
Потім, після кожної ітерації, перевіряється умова. Якщо умова оцінюється як true, цикл продовжує виконуватися;
якщо — як false, цикл завершується.

Цикл for
цикл for має змінну-лічильник. Змінна-лічильник оголошується за допомогою ключового слова let (оголошення через const видасть помилку). 
На кожній ітерації після виконання коду з тіла циклу вона змінює своє значення від заданого початкового до кінцевого з певним кроком.

for (initialization; condition; afterthought) {
  statement // Тіло циклу
}
for (let i = 0; i <= 20; i += 5) {
  console.log(i);
}
ітерація - це повторення. Ітерація циклу = повторення циклу.
*/
/* Інкремент (++) і декремент (--) — це операції, які відповідно збільшують або зменшують значення числової 
змінної на одиницю і одразу ж зберігають оновлене значення у цій змінній.
Існують два види інкременту та декременту: префіксний і постфіксний. І між ними є різниця, яку важко запам'ятати.
Якщо ми говоримо про префіксний інкремент ++х, то коли інтерпретатор його зустрічає, він спочатку збільшує значення змінної на 1, а тоді використовує
збільшене значення у виразі:
let x = 5;
const y = ++x;
console.log(x); // 6
console.log(y); // 6
Якщо ж інтерпретатор зустрічає постфіксний інкремент х++, то спочатку він використовує значення у виразі, а тоді збільшує значення змінної на 1.
let x = 5;
const y = x++;
console.log(x); // 6
console.log(y); // 5

Постфіксний інкремент b++:
Коли ми пишемо console.log(x++) то задаємо дві інструкції до виконання: 
1. вивести в консоль одиницю;
2. збільшити одиницю на 1.
Тому, якщо ми напишемо:
let b = 0;     - ініціалізуємо змінну
b++;           - збільшуємо її на одиницю, b = b + 1
console.log(b); // 1  - виводимо в консоль значення
console.log(b++); // 1  - тут спочатку відбувається виведення в консоль значення b, а тоді вже саме b збільшиться. Тому в консолі буде 1.
console.log(b); // 2 - тут бачимо вже збільшене значення.

console.log(b++ + 10); // 12 - бо з попер рядка бачимо,що b = 2.
Тобто перша інструкція це 2 + 10 порахувати. Друга інстр-я це вивести результат додаванна в консоль. Третя інструкція це збільшити b на 1.
console.log(b + 10); // 13 - тут b вже 3, бо в попер рядку воно збільшилось на 1

Тепер розглянемо з цього ракурсу ++b, тобто префіксний інкремент:
let b = 0;  - ініціалізуємо змінну
++b;        - збільшуємо її на одиницю, b = b + 1
console.log(b); // 1   - виводимо в консоль значення
console.log(++b); // 2  - тут спочатку відбувається збільшення b на одиницю, а тоді виведення в консоль, тому в консолі буде 2.
console.log(b); // 2 - тут бачимо збільшене значення
console.log(++b + 10); // 13 - перша інструкція: збільшити b на одиницю. Друга інстр-я 3 + 10 порахувати. Третя інстр-я: вивести результат в консоль.
console.log(b); // 3 


Приклад використання у циклі: (два цикли нижче працюю однаково, тому що i++ та ++i це одне і те саме, а саме i = i + 1)
for (let i = 0; i <= 5; i++) {
  console.log(i);   / 0 1 2 3 4 5
}

for (let i = 0; i <= 5; ++i) {
  console.log(i);   / 0 1 2 3 4 5
}

Так само з префіксним та постфіксним декрементом, тільки одиниця віднімається.

*/

// Оператор  break
/* Оператор break використовується в циклі для переривання його виконання. Коли оператор break зустрічається всередині циклу, виконання 
циклу негайно припиняється, і керування передається до наступної інструкції після циклу.

for (let i = 0; i < 10; i+=1) {
  console.log(i);  // 0 1 2 3 4 5 (коли і буде = 5, то в консоль виведеться речення і цикл зупиниться бо є break)

  if (i === 5) {
    console.log('Met the number 5, interrupt the execution of the cycle');
    break;
  }
}

console.log('Log after cycle');

*/

// Оператор break і функції
/*Коли оператор break зустрічається всередині циклу, виконання циклу негайно припиняється, і керування передається на наступну інструкцію
 за циклом, навіть якщо цикл знаходиться всередині функції. Тобто оператор break не припиняє виконання функції, а тільки перериває цикл.

 function findNumberFromFive(max, target) {
	console.log("Log in the body of the function before the cycle");

  for (let i = 5; i <= max; i += 1) {
    console.log("Current counter value i:", i);

    if (i === target) {
      console.log(`Found the number ${target}, interrupt the cycle`);
			break;
    }
  }

  console.log("Log in body function after cycle");
}

findNumberFromFive(10, 6);
console.log("Log after exiting function");


 Для того щоб переривати виконання одразу циклу і функції і повернути результат у зовнішній код, є оператор return.
 
 function findNumberFromFive(max, target) {
	console.log("Log in the body of the function before the cycle");

	for (let i = 5; i <= max; i += 1) {
	    console.log("Current counter value i:", i);
	
	    if (i === target) {
	      console.log(`Found the number ${target}, we make a return, interrupting the loop and function`);
				return i;
	    }
	  }

  // Цей console.log не виконується
  console.log("Log in body function after cycle");
}

const result = findNumberFromFive(10, 6);
console.log("Log after exiting function");
console.log(`Result of function execution ${result}`);

 
 */
