/*FIRST LESSON JAVA SCRIPT*/

//Під час інтерполяції змінну можна записувати у вигляді математичного виразу. Наприклад:
const dogs = 2;
const cats = 3;
const myPets = `I have ${dogs + cats} pets at home.`;
console.log(myPets); // I have 5 pets at home.
// Джс перед тим як видати цю строку, спочатку вирішив математичний вираз (додав дог до кет) і вже тоді присвоїв отриману строку змінній myPets,
// бо кожен матем. оператор має свою пріоритетність і в знака = ця пріоритетність дуже низька, тому спочатку виконується додавання, а тоді присвоєння(=).

/*JavaScript - це мова програмування. Ця мова:
-інтерпретована: інтерпретатор виконує код рядок за рядком, наперед весь код не збирається, не компілюється (це в стандартного джс, якщо ми говоримо про сборщики типу вебпак чи віт, то там є це компілювання)
-слаботипізована або динамічно типізована. У джс немає строгої типізації даних. Я можу задати змінній значення типу number, а нижче
змінити його на тип string і ніякої помилки не буде видано:
let a = 2;
a = 'hello'. 

-однопотокова: за одиницю часу виконується одна функція.
JavaScript — однопотокова мова, тобто в одну одиницю часу може виконуватися тільки одна інструкція. 
Це означає, що вже викликані функції, які не закінчили своє виконання, повинні чекати виконання функцій, 
викликаних усередині себе, для того щоб продовжити свою роботу.

function fnA() {
  console.log("Log inside fnA function before calling fnB");
  fnB();
  console.log("Log inside fnA function after fnB call");
}

function fnB() {
  console.log("Log inside fnB function");
}

console.log("Log before calling fnA");
fnA();
console.log("Log after calling fnA");

// "Log before calling fnA"
// "Log inside fnA function before calling fnB"
// "Log inside fnB function"
// "Log inside fnA function after fnB call"
// "Log after calling fnA"

-багатопарадигименна: є різні стилі написання коду (ООП, функціональне програмування);
-клієнт-серверна;

*/
// Явне приведення типів - використовуємо функції:
console.log(Number('5')); // 5
console.log(String(5)); // '5'
console.log(Number(undefined)); // NaN - це спеціальне значення в джс,яке виникає, коли ми намагаємося виконати математичний вираз не з числами, або
// привести до числа те, що  не може бути приведене до числа
console.log(Number(null)); // 0
console.log(typeof NaN); // number

// Булеве приведення треба вивчити напам'ять:
console.log(Boolean(5)); // true
console.log(Boolean(-5)); // true
console.log(Boolean(0)); // false
console.log(Boolean('')); // false
console.log(Boolean(' ')); // true
console.log(Boolean('a')); // true
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false

// Неявне перетворення типів - це коли тип перетворюється на інший без нашого втручання. Завжди треба віддавати перевагу явному перетворенню.

console.log(5 + '3'); // джс неявно перетворить 5 на строку і зробить конкатенацію і буде "53". Тобто 5 + "3" --> "5" + "3" --> "53"
// Тільки коли в тебе є строка і + джс буде перетворювати інший операнд на строку. В тебе є плюсик і строка, все, на виході буде строка.
// Якщо в тебе інші матем операції, такі як -, *, /, або наприклад операнди це не рядки, то джс буде все приводити до чисел.
console.log('5' - 'hello'); // NaN
console.log(true + null); // 1
console.log(true / 0); // Infinity
console.log((-1 * true) / 0); // -Infinity

// Важливо! Є такий унарний оператор +, він ставиться перед рядком і неявно перетворює його в число. Н-д:
console.log(+'5' + +'5'); //здається, що буде конкатенація і на виході отримаємо "55", але унарні оператори перетворять рядки на числа і буде 10.
console.log(-'5' + -'5'); // -10

/**Унарні оператори приймають лише один операнд, тобто вони діють лише на одне значення.Приклади унарних операторів:
+: Конвертує операнд у число. Наприклад, +5 дорівнює 5, а +'10' дорівнює 10.
-: Мінусує число (змінює його знак на протилежний). Наприклад, -5 дорівнює -5.
++: Інкрементує (збільшує на одиницю) значення операнду. Наприклад, якщо let x = 5;, то ++x дорівнює 6.
--: Декрементує (зменшує на одиницю) значення операнду. Наприклад, якщо let y = 10;, то --y дорівнює 9.
!: Логічне заперечення. Якщо операнд має значення true, то !operand буде false, і навпаки. Логічне «НІ» приводить операнд до логічного 
значення (true або false) і потім заперечує (інвертує) його, тобто заміняє на протилежне: true —> false, а false —> true.

Бінарні оператори приймають два операнди, наприклад:
- логічне АБО (condition 1 || condition 2)
- логічне І (condition 1 && condition 2)
*/

//Атбибути async та defer тегу <script> використовуються,коли є декілька файлів .js, які треба завантажити та запустити в певній послідовності.
//Скрипти можуть завантажуватись або послідовно або паралельно(тобто всі скрипти завантажуються одночасно). Н-д, якщо  в тебе є два скрипта, і
//  другий використовує інформацію з першого, тоді їх треба завантажувати послідовно. Якщо вони незалежні, тоді треба завантажувати паралельно.

// Перевірка на NaN:
console.log(Number.isNaN('hello' / 2)); // true
console.log(Number.isNaN(3)); // false

console.log(NaN === NaN); // false  (не дорівнює самому собі)

// Суворе та несуворе порівняння.
// Несуворе порівння == спочатку приведе операнди/значення до одного типу даних і тоді буде їх порівнювати.
console.log(5 == '5'); // true (Строки порівнювати легше, тому буде "5" == "5" і буде true)
console.log(null == undefined); // true (з таблиці порівнянь значень в конспекті LMS, треба вивчити)

// Суворе порівння порівнює спочатку за типом даних, якщо типи даних різні, одразу видає false. А якщо однакові, то порівнює за значенням.
console.log(5 === '5'); // false

// оператори порівняння. Результатом завжди буде буліан.
// Результат порівняння двох рядків залежить від лексикографічного словника або юнікоду, вони за ними порівнюються.
// Тобто всі строки порівнюються за таблицею юнікодів(спеціальне кодування кожного символу). в джс є метод charCodeAt(0).
// Н-д, за юніокдом рядок "1" буде "1".charCodeAt(0) --> 49, а рядок "2".charCodeAt(0) --> 50
console.log(5 > '7'); // приводить до числа, буде false.
console.log(10 > '7'); // true - приводить до числа

console.log('2' > '12'); // true, бо спочатку порівнюються перші символи 2 і 1. 2 більше за 1, тому тру.
console.log('241' > '245'); // false
console.log('a' > 'A'); // true

// ВИВЧИТИ
/* В JS при порівнянні(==) значення undefined і null є рівними, тобто, повертають true. В той самий час, при порівнянні(==) undefined і  null 
з усім іншим ви будете отримувати false, бо вони не будуть ні до чого приводитись, це буде просто null і undefined*/
// console.log(undefined == null); // true - *це просто треба вивчити*
// console.log(null == "null") // false
// console.log(null == 0); // false

// // При порівнянні через (>, <, >=, <=) null буде приводитись до 0, а undefined буде приводитись до NaN
// console.log(0 > null); // false -> 0 > 0
// console.log(0 >= null); // true -> 0 >= 0
console.log(undefined > 0); // false
console.log(undefined >= 0); //false
console.log(undefined > 1); //false
console.log(null == 0); // false
console.log(null == '0'); // false
console.log(null == 'null'); // false
console.log(undefined == 0); // false
console.log(undefined == 'undefined'); // false
console.log(undefined == undefined); // true

/* Методи Number.parseInt() та Number.parseFloat() повертають ціле число або число з плаваючою крапкою, за доп них можна дістати число з рядка
 н-д з '20.9px' --> 20.9  */

// Область видимості
function foo() {
  const value = 5; // ця константа доступна тільки у функції, бо функція це окрема локальна область видимості {}
}

// foo();
// console.log(value); // Uncaught ReferenceError: value is not defined

/**----------------------------------------------------------------------------------------------------------------------------------------- */

/*Задача: Напиши функцію calcBMI(weight, height),яка розраховує та повертає індекс маси тіла людини. Для цього треба вагу 
розділити на квадрат висоти.
Вага та висота будуть спеціально задані як рядки. Не цілі числа можуть бути задані у вигляді 24.7 або 24,7, 
тобто як роздільник дробової частини може бути кома. Індекс маси тіла необхідно округлити до однієї цифри після коми. */

function convertToDecimal(value) {
  return Number(value.replace(',', '.'));
}

function calcBMI(weight, height) {
  // 1 крок: замінюємо в рядку кому на крапку і одразу перетворюємо рядок в число. Метод replace() замінює лише перше зустрічне значення,
  // а не все, тобто якщо треба буде замінити всі 'a' на
  // 'o', то буде замінена лише перша знайдена буква "а". Щоб замінити все, є метод replaceAll().
  weight = convertToDecimal(weight);
  height = convertToDecimal(height);

  console.log(weight); // 50.3
  console.log(height); // 1.75
  // 2 крок:  розраховуємо індекс та округлюємо його до 1 знака після коми за доп. toFixed().
  const bmi = (weight / height ** 2).toFixed(1);
  // 3 крок: toFixed видає результат у вигляді рядка, тому перетворюємо його в число і одразу повертаємо, не створюючи лишню змінну.
  return Number(bmi);
}

console.log(calcBMI('50,3', '1.75')); // 16.4

/**----------------------------------------------------------------------------------------------------------------------------------------- */
// !Задача, дуже важлива для розуміння роботи джс і різних областях видимості.
let animal = 'horse';

function isAnimal(animal) {
  // ВАЖЛИВО! параметри функції - це змінні, а не константи і ми їх можемо змінювати всередині функції.
  // Тобто написавши animal = 'parrot', ми змінили значення параметру функції animal і присвоїли йому нове значення.
  animal = 'parrot';
  console.log(animal); // parrot
  return animal;
}

const resultIsAnimal = isAnimal('dog');
console.log(resultIsAnimal); // parrot.
console.log(animal); // horse

// Пояснення. Джс починає шукати змінну animal від місця, де її запитують, тобто ВІД console.log і ВВЕРХ і першим трапляється
// рядок animal = 'parrot', тому і в консолі відображається parrot.
// Якби цього рядку не було, він би дійшов до параметра animal і відобразив його значення в консолі, тоді в консолі вудобразився б рядок dog.
// Якби параметр мав іншу назву(не animal), тобі б в консолі відобразилось значення змінної let animal = 'horse'.
/* Тобто якщо в нас є локальна блочна область видимості, н-д функція, і у функції є console.log якоїсь змінної, то джс спочатку шукає цю змінну
 всередині функції і йде вверх,і якщо не знаходить, то далі виходить за межі функції і йде поступово рядок за рядком вверх, доки не знайде її  
 Модуль 1 урок 2 відео 2:01*/

/**----------------------------------------------------------------------------------------------------------------------------------------- */
