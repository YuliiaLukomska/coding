/* 
null && 'false' || 'Mango'
При визначення результату цього виразу, спочату все перетворюється на булевий тип, далі спрацьовують логічні оператори && або ||, і результатом
буде завжди значення одного з операндів: null, 'false' або 'Mango'.

У прикладі вище результатом виразу буде 'Mango'.
null && 'false' -> (оператор && шукає перше фолс) null
null || 'Mango' -> (оператор || шукає перше тру) 'Mango'

&& має вищу пріоритетність виконання, ніж || і буде виконуватись першим. 

Тернарний оператор - часто використовується, коли треба швидко зробити перевірку і результат зберегти в якусь змінну. 
const isOnline = 10 > 3 ? 'yes' : 'no';
console.log(isOnline);


Для того щоб зробити копію масиву найчастіше викор оператор spread(), або Array.from().

У const і у let блочна область видимості - це квадратні дужки.

Принцип(механізм) за яким функція, яка оголошена за доп. function declaration може бути викликана і до її оголошення і після 
називається хойстинг(hoisting) або підняття. Перед тим як запускати код джава скрипта, інтерпретатор знаходить всі функції, які оголошені як function 
declaration і підіймає їх на самий верх коду, на першу строку умовно кажучи, то ми можемо викликати function declaration в будь-якому місці
програми, тому що фактично, тому що вони всі фактично піднялися на самий верх коду. Цей механізм також працює з var. 

greet();

function greet(){
 return 'Hello user';
}

Але, важливий момент!
Ми не зможемо викликати функцію, якщо вона буде всередині блочної області видимості. Інтерпретатор не захожить всередину блоку, він 
шукає зсередини назовні. 

greet();  // Uncaught ReferenceError: greet is not defined

function wrap() {
  function greet() {
    console.log('hello');
  }
}

Псевдомасиви arguments буде часто використовуватись при роботі з DOM.

function foo() {
  console.log(arguments); // [1, 'apple', true]
}

foo(1, 'apple', true);

Мутування масиву - це поганий тон. Н-д, в тебе є масив, і тобі треба змінити якимось чином його елементи. Якщо ти будеш робити ось так:
array[index] = 'newValue';
То ти мутуєш початковий масив.
Найкращий варіант - створення копії масиву і робота з копією масиву.

*/
